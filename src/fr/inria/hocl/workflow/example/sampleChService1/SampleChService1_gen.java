/*
* DO NOT EDIT
* this class has been generated by fr.inria.hocl.core.hoclc2j version0.1->0.2
* on Fri Jan 21 18:19:41 CET 2011
*/

package fr.inria.hocl.workflow.example.sampleChService1;
import fr.inria.hocl.core.hocli.*;
import fr.inria.hocl.core.hocli.rmi.*;
import java.util.LinkedList;
import java.util.List;
import java.io.*;


public class SampleChService1_gen extends Solution {

	public SampleChService1_gen(){

		ExternalObject object;
		ReactionRule rule;
		String[] string;
		Tuple tuple;

		class PassInfo extends ReactionRule implements Serializable {
		
			
			public PassInfo(){
				super("passInfo", Shot.N_SHOT);
				setTrope(Trope.OPTIMIZER);
					AtomIterator[] _HOCL_atomIteratorArray0;
				_HOCL_atomIteratorArray0 = new AtomIterator[1];
				{
					AtomIterator[] _HOCL_atomIteratorArrayTuple0;
					_HOCL_atomIteratorArrayTuple0 = new AtomIterator[4];
					{
						class AtomIterator__HOCL_literal0 extends IteratorForExternal {
							public AtomIterator__HOCL_literal0(){
								access = Access.REWRITE;
							}
							@Override
							public boolean conditionSatisfied() {
								Atom atom;
								boolean satisfied;
								atom = iterator.getElement();
								satisfied = false;
								if (atom instanceof ExternalObject
								  && ((ExternalObject)atom).getObject() instanceof String) {
									
									IteratorForTuple _HOCL_tupleAtomIterator0 = (IteratorForTuple)permutation.getAtomIterator(0);
									String _HOCL_literal0 = (String)((IteratorForExternal)_HOCL_tupleAtomIterator0.getAtomIterator(0)).getObject();
									satisfied = _HOCL_literal0.equals("PASS");
								}
								return satisfied;
							}
						
						} // end of class AtomIterator__HOCL_literal0
						_HOCL_atomIteratorArrayTuple0[0] = new AtomIterator__HOCL_literal0();
					}
					{
						class AtomIterator_idChWS extends IteratorForExternal {
							public AtomIterator_idChWS(){
								access = Access.REWRITE;
							}
							@Override
							public boolean conditionSatisfied() {
								Atom atom;
								boolean satisfied;
								atom = iterator.getElement();
								satisfied = false;
								if (atom instanceof ExternalObject
								  && ((ExternalObject)atom).getObject() instanceof String) {
									satisfied = true;
								}
								return satisfied;
							}
						
						} // end of class AtomIterator_idChWS
						_HOCL_atomIteratorArrayTuple0[1] = new AtomIterator_idChWS();
					}
					{
						class AtomIterator_className extends IteratorForExternal {
							public AtomIterator_className(){
								access = Access.REWRITE;
							}
							@Override
							public boolean conditionSatisfied() {
								Atom atom;
								boolean satisfied;
								atom = iterator.getElement();
								satisfied = false;
								if (atom instanceof ExternalObject
								  && ((ExternalObject)atom).getObject() instanceof String) {
									
									IteratorForTuple _HOCL_tupleAtomIterator1 = (IteratorForTuple)permutation.getAtomIterator(0);
									String className = (String)((IteratorForExternal)_HOCL_tupleAtomIterator1.getAtomIterator(2)).getObject();
									IteratorForTuple _HOCL_tupleAtomIterator2 = (IteratorForTuple)permutation.getAtomIterator(0);
									IteratorForSolution _HOCL_iteratorSolution0 = (IteratorForSolution)_HOCL_tupleAtomIterator2.getAtomIterator(3);
									Molecule w = _HOCL_iteratorSolution0.getSubPermutation().getSolution().getContents();
									satisfied = ((IOSender.send("sampleChService1", className, w)));
								}
								return satisfied;
							}
						
						} // end of class AtomIterator_className
						_HOCL_atomIteratorArrayTuple0[2] = new AtomIterator_className();
					}
					{
						class IteratorSolution0 extends IteratorForSolution {
							protected Permutation makeSubPermutation(){
								Permutation perm;
								AtomIterator[] _HOCL_atomIteratorArray0;
								_HOCL_atomIteratorArray0 = new AtomIterator[0];
								
								MoleculeIterator[] _HOCL_moleculeIteratorArray0 = new MoleculeIterator[1];
								_HOCL_moleculeIteratorArray0[0] = new MoleculeIterator(1); // w
								
								perm = newPermutation(_HOCL_atomIteratorArray0, _HOCL_moleculeIteratorArray0);
								return perm;
							}
						
						} // class IteratorSolution0
						_HOCL_atomIteratorArrayTuple0[3] = new IteratorSolution0();
					}
					_HOCL_atomIteratorArray0[0] = new IteratorForTuple(_HOCL_atomIteratorArrayTuple0, PassInfo.this);
				}
				MoleculeIterator[] _HOCL_moleculeIteratorArray1 = new MoleculeIterator[0];
				permutation = newPermutation(_HOCL_atomIteratorArray0, _HOCL_moleculeIteratorArray1);
			}
		
			public PassInfo clone() {
				 return new PassInfo();
			}
			public void addType(String s){}
		
			// compute result of the rule passInfo
			protected Molecule computeResult(){
				ExternalObject object;
				ReactionRule rule;
				String[] string;
				Tuple tuple;
				
				IteratorForTuple _HOCL_tupleAtomIterator3 = (IteratorForTuple)permutation.getAtomIterator(0);
				String idChWS = (String)((IteratorForExternal)_HOCL_tupleAtomIterator3.getAtomIterator(1)).getObject();
				Molecule mol0 = new Molecule();
				Tuple tuple0 = new Tuple(2);
				tuple0.set(0, new ExternalObject("Success_Pass"));
				tuple0.set(1, new ExternalObject(idChWS));
				tuple = tuple0;
				mol0.add(tuple);
				this.addType("Tuple");
				
				
				return mol0;
			}
		
		} // end of class PassInfo
		
		
		
		
		
		class PutResultInPass extends ReactionRule implements Serializable {
		
			
			public PutResultInPass(){
				super("putResultInPass", Shot.N_SHOT);
				setTrope(Trope.OPTIMIZER);
					AtomIterator[] _HOCL_atomIteratorArray2;
				_HOCL_atomIteratorArray2 = new AtomIterator[2];
				{
					AtomIterator[] _HOCL_atomIteratorArrayTuple1;
					_HOCL_atomIteratorArrayTuple1 = new AtomIterator[3];
					{
						class AtomIterator__HOCL_literal10 extends IteratorForExternal {
							public AtomIterator__HOCL_literal10(){
								access = Access.REWRITE;
							}
							@Override
							public boolean conditionSatisfied() {
								Atom atom;
								boolean satisfied;
								atom = iterator.getElement();
								satisfied = false;
								if (atom instanceof ExternalObject
								  && ((ExternalObject)atom).getObject() instanceof String) {
									
									IteratorForTuple _HOCL_tupleAtomIterator4 = (IteratorForTuple)permutation.getAtomIterator(0);
									String _HOCL_literal10 = (String)((IteratorForExternal)_HOCL_tupleAtomIterator4.getAtomIterator(0)).getObject();
									satisfied = _HOCL_literal10.equals("DEST");
								}
								return satisfied;
							}
						
						} // end of class AtomIterator__HOCL_literal10
						_HOCL_atomIteratorArrayTuple1[0] = new AtomIterator__HOCL_literal10();
					}
					{
						class AtomIterator_nameRegService extends IteratorForExternal {
							public AtomIterator_nameRegService(){
								access = Access.REWRITE;
							}
							@Override
							public boolean conditionSatisfied() {
								Atom atom;
								boolean satisfied;
								atom = iterator.getElement();
								satisfied = false;
								if (atom instanceof ExternalObject
								  && ((ExternalObject)atom).getObject() instanceof String) {
									satisfied = true;
								}
								return satisfied;
							}
						
						} // end of class AtomIterator_nameRegService
						_HOCL_atomIteratorArrayTuple1[1] = new AtomIterator_nameRegService();
					}
					{
						class AtomIterator_className extends IteratorForExternal {
							public AtomIterator_className(){
								access = Access.REWRITE;
							}
							@Override
							public boolean conditionSatisfied() {
								Atom atom;
								boolean satisfied;
								atom = iterator.getElement();
								satisfied = false;
								if (atom instanceof ExternalObject
								  && ((ExternalObject)atom).getObject() instanceof String) {
									satisfied = true;
								}
								return satisfied;
							}
						
						} // end of class AtomIterator_className
						_HOCL_atomIteratorArrayTuple1[2] = new AtomIterator_className();
					}
					_HOCL_atomIteratorArray2[0] = new IteratorForTuple(_HOCL_atomIteratorArrayTuple1, PutResultInPass.this);
				}
				{
					AtomIterator[] _HOCL_atomIteratorArrayTuple2;
					_HOCL_atomIteratorArrayTuple2 = new AtomIterator[3];
					{
						class AtomIterator__HOCL_literal11 extends IteratorForExternal {
							public AtomIterator__HOCL_literal11(){
								access = Access.REWRITE;
							}
							@Override
							public boolean conditionSatisfied() {
								Atom atom;
								boolean satisfied;
								atom = iterator.getElement();
								satisfied = false;
								if (atom instanceof ExternalObject
								  && ((ExternalObject)atom).getObject() instanceof String) {
									
									IteratorForTuple _HOCL_tupleAtomIterator5 = (IteratorForTuple)permutation.getAtomIterator(1);
									String _HOCL_literal11 = (String)((IteratorForExternal)_HOCL_tupleAtomIterator5.getAtomIterator(0)).getObject();
									satisfied = _HOCL_literal11.equals("RESULT");
								}
								return satisfied;
							}
						
						} // end of class AtomIterator__HOCL_literal11
						_HOCL_atomIteratorArrayTuple2[0] = new AtomIterator__HOCL_literal11();
					}
					{
						class AtomIterator_idChWS extends IteratorForExternal {
							public AtomIterator_idChWS(){
								access = Access.REWRITE;
							}
							@Override
							public boolean conditionSatisfied() {
								Atom atom;
								boolean satisfied;
								atom = iterator.getElement();
								satisfied = false;
								if (atom instanceof ExternalObject
								  && ((ExternalObject)atom).getObject() instanceof String) {
									satisfied = true;
								}
								return satisfied;
							}
						
						} // end of class AtomIterator_idChWS
						_HOCL_atomIteratorArrayTuple2[1] = new AtomIterator_idChWS();
					}
					{
						class AtomIterator_result extends IteratorForExternal {
							public AtomIterator_result(){
								access = Access.REWRITE;
							}
							@Override
							public boolean conditionSatisfied() {
								Atom atom;
								boolean satisfied;
								atom = iterator.getElement();
								satisfied = false;
								if (atom instanceof ExternalObject
								  && ((ExternalObject)atom).getObject() instanceof String) {
									satisfied = true;
								}
								return satisfied;
							}
						
						} // end of class AtomIterator_result
						_HOCL_atomIteratorArrayTuple2[2] = new AtomIterator_result();
					}
					_HOCL_atomIteratorArray2[1] = new IteratorForTuple(_HOCL_atomIteratorArrayTuple2, PutResultInPass.this);
				}
				MoleculeIterator[] _HOCL_moleculeIteratorArray2 = new MoleculeIterator[0];
				permutation = newPermutation(_HOCL_atomIteratorArray2, _HOCL_moleculeIteratorArray2);
			}
		
			public PutResultInPass clone() {
				 return new PutResultInPass();
			}
			public void addType(String s){}
		
			// compute result of the rule putResultInPass
			protected Molecule computeResult(){
				ExternalObject object;
				ReactionRule rule;
				String[] string;
				Tuple tuple;
				
				IteratorForTuple _HOCL_tupleAtomIterator6 = (IteratorForTuple)permutation.getAtomIterator(0);
				String nameRegService = (String)((IteratorForExternal)_HOCL_tupleAtomIterator6.getAtomIterator(1)).getObject();
				IteratorForTuple _HOCL_tupleAtomIterator7 = (IteratorForTuple)permutation.getAtomIterator(1);
				String idChWS = (String)((IteratorForExternal)_HOCL_tupleAtomIterator7.getAtomIterator(1)).getObject();
				IteratorForTuple _HOCL_tupleAtomIterator8 = (IteratorForTuple)permutation.getAtomIterator(0);
				String className = (String)((IteratorForExternal)_HOCL_tupleAtomIterator8.getAtomIterator(2)).getObject();
				IteratorForTuple _HOCL_tupleAtomIterator9 = (IteratorForTuple)permutation.getAtomIterator(1);
				String result = (String)((IteratorForExternal)_HOCL_tupleAtomIterator9.getAtomIterator(2)).getObject();
				Molecule mol6 = new Molecule();
				Tuple tuple1 = new Tuple(4);
				tuple1.set(0, new ExternalObject("PASS"));
				tuple1.set(1, new ExternalObject(nameRegService));
				tuple1.set(2, new ExternalObject(className));
				Solution solution1 = new Solution();
				{
					Molecule mol7 = new Molecule();
					Tuple tuple2 = new Tuple(3);
					tuple2.set(0, new ExternalObject("COMPLETED"));
					tuple2.set(1, new ExternalObject(idChWS));
					tuple2.set(2, new ExternalObject(result));
					tuple = tuple2;
					mol7.add(tuple);
					this.addType("Tuple");
					
					
					solution1.addMolecule(mol7);
				}
				tuple1.set(3, solution1);
				tuple = tuple1;
				mol6.add(tuple);
				this.addType("Tuple");
				
				
				Tuple tuple3 = new Tuple(3);
				tuple3.set(0, new ExternalObject("RESULT"));
				tuple3.set(1, new ExternalObject(idChWS));
				tuple3.set(2, new ExternalObject(result));
				tuple = tuple3;
				mol6.add(tuple);
				this.addType("Tuple");
				
				
				return mol6;
			}
		
		} // end of class PutResultInPass
		
		
		
		
		
		
		
		
		
		
		
		
		Molecule mol25 = new Molecule();
		Tuple tuple4 = new Tuple(3);
		tuple4.set(0, new ExternalObject("CALL"));
		tuple4.set(1, new ExternalObject("ChWS_1"));
		tuple4.set(2, new ExternalObject("http://localhost:8080/ode/processes/ConcatStringService"));
		tuple = tuple4;
		mol25.add(tuple);
		this.addType("Tuple");
		
		
		Tuple tuple5 = new Tuple(2);
		tuple5.set(0, new ExternalObject("TMP_VAR"));
		tuple5.set(1, new ExternalObject(2));
		tuple = tuple5;
		mol25.add(tuple);
		this.addType("Tuple");
		
		
		rule = new PutResultInPass();
		mol25.add(rule);
		this.addType(rule.getName());
		
		
		this.addMolecule(mol25);
		this.addType("Solution");
		this.addType("Integer");
		this.addType("String");
		this.addType("Tuple");

	}

	public Molecule addElement(){
		String input = "";
		ExternalObject obj;
		ReactionRule r;
		Molecule mol = new Molecule();
		int choice;

		System.out.println("Create the element that you want to add/remove.\n");
		System.out.println("What kind of element you want to create? (input the number) \n ");
		System.out.println("Supported Elements:");
		System.out.println(this.displayTypes());

		try {
			input += new BufferedReader(new InputStreamReader(System.in)).readLine();
		} catch (IOException e1) {
			e1.printStackTrace();
		}

		try{

			choice = Integer.decode(input);
			input = this.getiAllType(choice-1);
			if(input.length()==0)
				System.out.println("Null pointer!");
			else if (input.equals("Tuple")){
				mol = new Molecule();
				mol.add(generateTupleElement());

				}

			else if (input.equals("Solution")){
				mol = new Molecule();
				mol.add(generateSolutionElement());

				}

			else if (input.equals("String")){
				mol = new Molecule();
				obj = new ExternalObject(generateStringElement());
				mol.add(obj);
				}

			else if (input.equals("Integer")){
				mol = new Molecule();
				obj = new ExternalObject(generateIntegerElement());
				mol.add(obj);
				}

			else if (input.equals("putResultInPass")){
				mol = new Molecule();
				r = new PutResultInPass();
				mol.add(r);
				}

				else{
					Package pack = this.getClass().getPackage();
					String packageName = pack.getName();
					String ts = input.substring(0, 1).toUpperCase()+input.substring(1);
					ReactionRule m = (ReactionRule) Class.forName(packageName+"."+ts).newInstance();
 					mol.add(m);

					System.out.println("The new rule has been added!");
			}

		return mol;
		}

		catch  (Exception e) {

			System.out.println("Input Error! Please input *NUMBER* while not string!");			return mol;		}

	}
	public Molecule addElementSubSolution(String line) throws IOException{
		Molecule mol = new Molecule();
		String[] s = line.split("\\ ");
		if(s.length!=2){
			String errorLog=	"Input command with wrong format.\n"
			+	"Use 'put' command in the following ways:\n"
			+	"1: 'put'; (just put an element in the container;)\n"
			+	"2: 'put path' ex.: put ./SubSolition1/SubSolution1-1 (put an element in the indicated subsolution.)\n";
			System.out.println(errorLog);
		}

		else{
			//System.out.println("The length of input command is: " + s.length +"\n");
			//System.out.println("S0 is: " + s[0] +"\n");
			//System.out.println("S1 is: " + s[1] +"\n");
			String[] path = s[1].split("\\/");
			int size = path.length;
			Tuple[] tuple = new Tuple[size-1];

			tuple[size-2] = new Tuple(3);
			tuple[size-2].set(0, new ExternalObject("INSERT"));
			tuple[size-2].set(1, new ExternalObject(path[size-1]));
			tuple[size-2].set(2, (this.generateSolutionElement()));

			for (int i = size-3;i>=0;i--){
				tuple[i] = new Tuple(3);
				tuple[i].set(0, new ExternalObject("INSERT"));
				tuple[i].set(1, new ExternalObject(path[i+1]));
				Solution so = new Solution();
				Molecule mo = new Molecule();
				mo.add(tuple[i+1]);
				so.addMolecule(mo);
				tuple[i].set(2, so);
			}

			mol.add(tuple[0]);
		}
		return mol;
	}

	public Molecule addRemoveTuple() throws IOException{
		System.out.println("We are going to construct a solution for all the elements that you want to remove.");
		Tuple t = new Tuple(2);
		t.set(0, new ExternalObject("REMOVE"));
		t.set(1, this.generateSolutionElement());
		Molecule mo = new Molecule();
		mo.add(t);
		return mo;
	}

	public Molecule addInheritRemoveTuple(String line) throws IOException{
				Molecule m = new Molecule();
		String[] s = line.split("\\ ");
		if(s.length!=2){
			String errorLog=	"Input command with wrong format.\n"
			+	"Use 'get' command in the following ways:\n"
			+	"1: 'get'; (just get an element in the container;)\n"
			+	"2: 'get path' ex.: get ./SubSolition1/SubSolution1-1 (get the elements in the indicated subsolution.)\n";
			System.out.println(errorLog);
		}

		else{
			if(!s[1].contains("/"))
				System.out.println("You have given a wrong solution path.\n");
			else{
				System.out.println("We are going to construct a solution for all the elements that you want to remove.");
				String[] path = s[1].split("\\/");
				int size = path.length;
				Tuple[] tuple = new Tuple[size-1];

				tuple[size-2] = new Tuple(3);
				tuple[size-2].set(0, new ExternalObject("REMOVE"));
				tuple[size-2].set(1, new ExternalObject(path[size-1]));
				Solution so = new Solution();
				Molecule mo = new Molecule();
				Tuple tt = new Tuple(2);
				tt.set(0, new ExternalObject("REMOVE"));
				tt.set(1,this.generateSolutionElement());
				mo.add(tt);
				so.addMolecule(mo);
				tuple[size-2].set(2, so);
				for (int i = size-3;i>=0;i--){
					tuple[i] = new Tuple(3);
					tuple[i].set(0, new ExternalObject("REMOVE"));
					tuple[i].set(1, new ExternalObject(path[i+1]));
					so = new Solution();
					mo = new Molecule();
					mo.add(tuple[i+1]);
					so.addMolecule(mo);
					tuple[i].set(2, so);
				}

				m.add(tuple[0]);
			}
		}
		return m;
	}



	public String generateStringElement() throws IOException{;
		System.out.println("Enter your String:\n");
		String input = new BufferedReader(new InputStreamReader(System.in)).readLine();
		return new String(input);

	}
	public Integer generateIntegerElement() throws IOException{;
		System.out.println("Enter your Integer:\n");
		String input = new BufferedReader(new InputStreamReader(System.in)).readLine();
		return new Integer(input);

	}


	public Tuple generateTupleElement() throws IOException{
		int num;
		String input;

		System.out.println("How many elements in the tuple?\n");
		input = new BufferedReader(new InputStreamReader(System.in)).readLine();
		num = Integer.decode(input);

		Tuple t = new Tuple (num);
		for (int i=0;i<num;i++){
			System.out.print("Enter the type for the ");
			int j = i % 10;
			if (j == 0)
				System.out.println((i+1) + "st element. \n");
			else if (j == 1)
				System.out.println((i+1) + "nd element. \n");
			else if (j == 2)
				System.out.println((i+1) + "rd element. \n");
			else 
				 System.out.println((i+1) + "th element. \n");
			System.out.println("Types:");
			System.out.println(this.displayTypes());
			input = new BufferedReader(new InputStreamReader(System.in)).readLine();

			while(input.length()==0){
				System.out.println("Enter the type of the element.");
				input = new BufferedReader(new InputStreamReader(System.in)).readLine();
			}
			 int choice = Integer.decode(input);
			 input = this.getiAllType(choice-1);
			if(input.equals("Tuple")){
				t.set(i, generateTupleElement());
			}

			else if(input.equals("Solution")){
					t.set(i, generateSolutionElement());
				}

			else if(input.equals("String")){
				t.set(i, new ExternalObject (generateStringElement()));
			}

			else if(input.equals("Integer")){
				t.set(i, new ExternalObject (generateIntegerElement()));
			}

			else if(input.equals("putResultInPass")){
				t.set(i, new PutResultInPass());
			}

		}
		return t;
	}



	public Solution generateSolutionElement() throws IOException{
		int sign = 0;
		String input;
		Solution sol = new Solution ();
		Molecule mol = new Molecule();
		while(sign == 0){
			System.out.println("Do you want to add an element in this solution? (y/n)");
			String stop = new BufferedReader(new InputStreamReader(System.in)).readLine();

			if (stop.equals("yes")||stop.equals("y")||stop.equals("YES")||stop.equals("Y")){
				System.out.println("Enter the type of the element.\n");
				System.out.println("Types:");
				System.out.println(this.displayTypes());
				input = new BufferedReader(new InputStreamReader(System.in)).readLine();

				while(input.length()==0){
					System.out.println("Enter the type of the element.");
					input = new BufferedReader(new InputStreamReader(System.in)).readLine();
				}
				int choice = Integer.decode(input);
				input = this.getiAllType(choice-1);
				if(input.equals("Tuple")){
					mol = new Molecule();
					mol.add(generateTupleElement());
					sol.addMolecule(mol);
				}

				else if(input.equals("Solution")){
					mol.add(generateSolutionElement());
					sol.addMolecule(mol);

				}

				else if(input.equals("String")){
					mol = new Molecule();
					mol.add(new ExternalObject (generateStringElement())) ;
					sol.addMolecule(mol);
				}

				else if(input.equals("Integer")){
					mol = new Molecule();
					mol.add(new ExternalObject (generateIntegerElement())) ;
					sol.addMolecule(mol);
				}

				else if(input.equals("putResultInPass")){
					mol = new Molecule();
					mol.add(new PutResultInPass());
					sol.addMolecule(mol);
				}

				else{
					try{
						String ts = input.substring(0, 1).toUpperCase()+input.substring(1);
						ReactionRule m = (ReactionRule) Class.forName(input).newInstance();
						mol.add(m);
						sol.addMolecule(mol);
					}catch(Exception e){
						System.out.println("Error: (Test1_gen.generateSolutionElement()): "+e+".");
					}
				}
			}

			else{sign=1;}

		}

		return sol;
	}
	public void addType(String s){
		int sign=0;

		if(this.getAllTypeSize()==0){
			this.addToAllTypes(s);
		}

		else{
			for (int i=0;i<this.getAllTypeSize();i++){
				if (this.getiAllType(i).equals(s)){
					sign=1;
					break;
				}
			}
			if (sign==0){
				this.addToAllTypes(s);
			}
		}
	}

	public String displayTypes (){

		String types = "";

		if(this.getAllTypeSize()==0){
			types = "No element in the multi-set.\n";
		}
		else{
			for(int i=0;i<this.getAllTypeSize();i++){
			if (!this.getiAllType(i).equals("IOSender"))
				types += i+1 +": "+this.getiAllType(i)+";\n";
			}
		}
		return types;
	}
} // class SampleChService1_gen

