/*
* DO NOT EDIT
* this class has been generated by fr.inria.hocl.core.hoclc2j version0.1->0.2
* on Fri Jan 21 18:52:35 CET 2011
*/

package fr.inria.hocl.workflow.example.clientChService;
import fr.inria.hocl.core.hocli.*;
import fr.inria.hocl.core.hocli.*;
import fr.inria.hocl.core.hocli.rmi.*;
import java.util.LinkedList;
import java.util.List;
import java.io.*;


public class ClientChService_gen extends Solution {

	public ClientChService_gen(){

		ExternalObject object;
		ReactionRule rule;
		String[] string;
		Tuple tuple;

		class PassInfo extends ReactionRule implements Serializable {
		
			
			public PassInfo(){
				super("passInfo", Shot.N_SHOT);
				setTrope(Trope.OPTIMIZER);
					AtomIterator[] _HOCL_atomIteratorArray0;
				_HOCL_atomIteratorArray0 = new AtomIterator[1];
				{
					AtomIterator[] _HOCL_atomIteratorArrayTuple0;
					_HOCL_atomIteratorArrayTuple0 = new AtomIterator[4];
					{
						class AtomIterator__HOCL_literal0 extends IteratorForExternal {
							public AtomIterator__HOCL_literal0(){
								access = Access.REWRITE;
							}
							@Override
							public boolean conditionSatisfied() {
								Atom atom;
								boolean satisfied;
								atom = iterator.getElement();
								satisfied = false;
								if (atom instanceof ExternalObject
								  && ((ExternalObject)atom).getObject() instanceof String) {
									
									IteratorForTuple _HOCL_tupleAtomIterator0 = (IteratorForTuple)permutation.getAtomIterator(0);
									String _HOCL_literal0 = (String)((IteratorForExternal)_HOCL_tupleAtomIterator0.getAtomIterator(0)).getObject();
									satisfied = _HOCL_literal0.equals("PASS");
								}
								return satisfied;
							}
						
						} // end of class AtomIterator__HOCL_literal0
						_HOCL_atomIteratorArrayTuple0[0] = new AtomIterator__HOCL_literal0();
					}
					{
						class AtomIterator_idChWS extends IteratorForExternal {
							public AtomIterator_idChWS(){
								access = Access.REWRITE;
							}
							@Override
							public boolean conditionSatisfied() {
								Atom atom;
								boolean satisfied;
								atom = iterator.getElement();
								satisfied = false;
								if (atom instanceof ExternalObject
								  && ((ExternalObject)atom).getObject() instanceof String) {
									satisfied = true;
								}
								return satisfied;
							}
						
						} // end of class AtomIterator_idChWS
						_HOCL_atomIteratorArrayTuple0[1] = new AtomIterator_idChWS();
					}
					{
						class AtomIterator_className extends IteratorForExternal {
							public AtomIterator_className(){
								access = Access.REWRITE;
							}
							@Override
							public boolean conditionSatisfied() {
								Atom atom;
								boolean satisfied;
								atom = iterator.getElement();
								satisfied = false;
								if (atom instanceof ExternalObject
								  && ((ExternalObject)atom).getObject() instanceof String) {
									
									IteratorForTuple _HOCL_tupleAtomIterator1 = (IteratorForTuple)permutation.getAtomIterator(0);
									String className = (String)((IteratorForExternal)_HOCL_tupleAtomIterator1.getAtomIterator(2)).getObject();
									IteratorForTuple _HOCL_tupleAtomIterator2 = (IteratorForTuple)permutation.getAtomIterator(0);
									IteratorForSolution _HOCL_iteratorSolution0 = (IteratorForSolution)_HOCL_tupleAtomIterator2.getAtomIterator(3);
									Molecule w = _HOCL_iteratorSolution0.getSubPermutation().getSolution().getContents();
									satisfied = ((IOSender.send("clientChService", className, w)));
								}
								return satisfied;
							}
						
						} // end of class AtomIterator_className
						_HOCL_atomIteratorArrayTuple0[2] = new AtomIterator_className();
					}
					{
						class IteratorSolution0 extends IteratorForSolution {
							protected Permutation makeSubPermutation(){
								Permutation perm;
								AtomIterator[] _HOCL_atomIteratorArray0;
								_HOCL_atomIteratorArray0 = new AtomIterator[0];
								
								MoleculeIterator[] _HOCL_moleculeIteratorArray0 = new MoleculeIterator[1];
								_HOCL_moleculeIteratorArray0[0] = new MoleculeIterator(1); // w
								
								perm = newPermutation(_HOCL_atomIteratorArray0, _HOCL_moleculeIteratorArray0);
								return perm;
							}
						
						} // class IteratorSolution0
						_HOCL_atomIteratorArrayTuple0[3] = new IteratorSolution0();
					}
					_HOCL_atomIteratorArray0[0] = new IteratorForTuple(_HOCL_atomIteratorArrayTuple0, PassInfo.this);
				}
				MoleculeIterator[] _HOCL_moleculeIteratorArray1 = new MoleculeIterator[0];
				permutation = newPermutation(_HOCL_atomIteratorArray0, _HOCL_moleculeIteratorArray1);
			}
		
			public PassInfo clone() {
				 return new PassInfo();
			}
			public void addType(String s){}
		
			// compute result of the rule passInfo
			protected Molecule computeResult(){
				ExternalObject object;
				ReactionRule rule;
				String[] string;
				Tuple tuple;
				
				IteratorForTuple _HOCL_tupleAtomIterator3 = (IteratorForTuple)permutation.getAtomIterator(0);
				String idChWS = (String)((IteratorForExternal)_HOCL_tupleAtomIterator3.getAtomIterator(1)).getObject();
				Molecule mol0 = new Molecule();
				Tuple tuple0 = new Tuple(2);
				tuple0.set(0, new ExternalObject("Success_Pass"));
				tuple0.set(1, new ExternalObject(idChWS));
				tuple = tuple0;
				mol0.add(tuple);
				this.addType("Tuple");
				
				
				return mol0;
			}
		
		} // end of class PassInfo
		
		
		
		
		
		
		
		
		
		
		class StartExecDiscriminator extends ReactionRule implements Serializable {
		
			
			public StartExecDiscriminator(){
				super("startExecDiscriminator", Shot.ONE_SHOT);
				setTrope(Trope.OPTIMIZER);
					AtomIterator[] _HOCL_atomIteratorArray2;
				_HOCL_atomIteratorArray2 = new AtomIterator[1];
				{
					AtomIterator[] _HOCL_atomIteratorArrayTuple1;
					_HOCL_atomIteratorArrayTuple1 = new AtomIterator[2];
					{
						class AtomIterator__HOCL_literal18 extends IteratorForExternal {
							public AtomIterator__HOCL_literal18(){
								access = Access.REWRITE;
							}
							@Override
							public boolean conditionSatisfied() {
								Atom atom;
								boolean satisfied;
								atom = iterator.getElement();
								satisfied = false;
								if (atom instanceof ExternalObject
								  && ((ExternalObject)atom).getObject() instanceof String) {
									
									IteratorForTuple _HOCL_tupleAtomIterator4 = (IteratorForTuple)permutation.getAtomIterator(0);
									String _HOCL_literal18 = (String)((IteratorForExternal)_HOCL_tupleAtomIterator4.getAtomIterator(0)).getObject();
									satisfied = _HOCL_literal18.equals("DISCRIMINATOR");
								}
								return satisfied;
							}
						
						} // end of class AtomIterator__HOCL_literal18
						_HOCL_atomIteratorArrayTuple1[0] = new AtomIterator__HOCL_literal18();
					}
					{
						class AtomIterator_value extends IteratorForExternal {
							public AtomIterator_value(){
								access = Access.REWRITE;
							}
							@Override
							public boolean conditionSatisfied() {
								Atom atom;
								boolean satisfied;
								atom = iterator.getElement();
								satisfied = false;
								if (atom instanceof ExternalObject
								  && ((ExternalObject)atom).getObject() instanceof String) {
									
									IteratorForTuple _HOCL_tupleAtomIterator5 = (IteratorForTuple)permutation.getAtomIterator(0);
									String value = (String)((IteratorForExternal)_HOCL_tupleAtomIterator5.getAtomIterator(1)).getObject();
									satisfied = (value.equals("Yes"));
								}
								return satisfied;
							}
						
						} // end of class AtomIterator_value
						_HOCL_atomIteratorArrayTuple1[1] = new AtomIterator_value();
					}
					_HOCL_atomIteratorArray2[0] = new IteratorForTuple(_HOCL_atomIteratorArrayTuple1, StartExecDiscriminator.this);
				}
				MoleculeIterator[] _HOCL_moleculeIteratorArray2 = new MoleculeIterator[0];
				permutation = newPermutation(_HOCL_atomIteratorArray2, _HOCL_moleculeIteratorArray2);
			}
		
			public StartExecDiscriminator clone() {
				 return new StartExecDiscriminator();
			}
			public void addType(String s){}
		
			// compute result of the rule startExecDiscriminator
			protected Molecule computeResult(){
				ExternalObject object;
				ReactionRule rule;
				String[] string;
				Tuple tuple;
				
				Molecule mol15 = new Molecule();
				Tuple tuple1 = new Tuple(2);
				tuple1.set(0, new ExternalObject("INVOKE"));
				tuple1.set(1, new ExternalObject(1));
				tuple = tuple1;
				mol15.add(tuple);
				this.addType("Tuple");
				
				
				return mol15;
			}
		
		} // end of class StartExecDiscriminator
		
		
		
		
		
		
		
		class Reset extends ReactionRule implements Serializable {
		
			
			public Reset(){
				super("reset", Shot.ONE_SHOT);
				setTrope(Trope.EXPANSER);
					AtomIterator[] _HOCL_atomIteratorArray3;
				_HOCL_atomIteratorArray3 = new AtomIterator[3];
				{
					AtomIterator[] _HOCL_atomIteratorArrayTuple2;
					_HOCL_atomIteratorArrayTuple2 = new AtomIterator[2];
					{
						class AtomIterator__HOCL_literal31 extends IteratorForExternal {
							public AtomIterator__HOCL_literal31(){
								access = Access.REWRITE;
							}
							@Override
							public boolean conditionSatisfied() {
								Atom atom;
								boolean satisfied;
								atom = iterator.getElement();
								satisfied = false;
								if (atom instanceof ExternalObject
								  && ((ExternalObject)atom).getObject() instanceof String) {
									
									IteratorForTuple _HOCL_tupleAtomIterator6 = (IteratorForTuple)permutation.getAtomIterator(0);
									String _HOCL_literal31 = (String)((IteratorForExternal)_HOCL_tupleAtomIterator6.getAtomIterator(0)).getObject();
									satisfied = _HOCL_literal31.equals("RESET");
								}
								return satisfied;
							}
						
						} // end of class AtomIterator__HOCL_literal31
						_HOCL_atomIteratorArrayTuple2[0] = new AtomIterator__HOCL_literal31();
					}
					{
						class IteratorSolution7 extends IteratorForSolution {
							protected Permutation makeSubPermutation(){
								Permutation perm;
								AtomIterator[] _HOCL_atomIteratorArray3;
								_HOCL_atomIteratorArray3 = new AtomIterator[0];
								
								MoleculeIterator[] _HOCL_moleculeIteratorArray3 = new MoleculeIterator[1];
								_HOCL_moleculeIteratorArray3[0] = new MoleculeIterator(1); // w
								
								perm = newPermutation(_HOCL_atomIteratorArray3, _HOCL_moleculeIteratorArray3);
								return perm;
							}
						
						} // class IteratorSolution7
						_HOCL_atomIteratorArrayTuple2[1] = new IteratorSolution7();
					}
					_HOCL_atomIteratorArray3[0] = new IteratorForTuple(_HOCL_atomIteratorArrayTuple2, Reset.this);
				}
				{
					AtomIterator[] _HOCL_atomIteratorArrayTuple3;
					_HOCL_atomIteratorArrayTuple3 = new AtomIterator[2];
					{
						class AtomIterator__HOCL_literal32 extends IteratorForExternal {
							public AtomIterator__HOCL_literal32(){
								access = Access.REWRITE;
							}
							@Override
							public boolean conditionSatisfied() {
								Atom atom;
								boolean satisfied;
								atom = iterator.getElement();
								satisfied = false;
								if (atom instanceof ExternalObject
								  && ((ExternalObject)atom).getObject() instanceof String) {
									
									IteratorForTuple _HOCL_tupleAtomIterator7 = (IteratorForTuple)permutation.getAtomIterator(1);
									String _HOCL_literal32 = (String)((IteratorForExternal)_HOCL_tupleAtomIterator7.getAtomIterator(0)).getObject();
									satisfied = _HOCL_literal32.equals("LOCKED");
								}
								return satisfied;
							}
						
						} // end of class AtomIterator__HOCL_literal32
						_HOCL_atomIteratorArrayTuple3[0] = new AtomIterator__HOCL_literal32();
					}
					{
						class AtomIterator_value extends IteratorForExternal {
							public AtomIterator_value(){
								access = Access.REWRITE;
							}
							@Override
							public boolean conditionSatisfied() {
								Atom atom;
								boolean satisfied;
								atom = iterator.getElement();
								satisfied = false;
								if (atom instanceof ExternalObject
								  && ((ExternalObject)atom).getObject() instanceof Integer) {
									satisfied = true;
								}
								return satisfied;
							}
						
						} // end of class AtomIterator_value
						_HOCL_atomIteratorArrayTuple3[1] = new AtomIterator_value();
					}
					_HOCL_atomIteratorArray3[1] = new IteratorForTuple(_HOCL_atomIteratorArrayTuple3, Reset.this);
				}
				{
					AtomIterator[] _HOCL_atomIteratorArrayTuple4;
					_HOCL_atomIteratorArrayTuple4 = new AtomIterator[2];
					{
						class AtomIterator__HOCL_literal33 extends IteratorForExternal {
							public AtomIterator__HOCL_literal33(){
								access = Access.REWRITE;
							}
							@Override
							public boolean conditionSatisfied() {
								Atom atom;
								boolean satisfied;
								atom = iterator.getElement();
								satisfied = false;
								if (atom instanceof ExternalObject
								  && ((ExternalObject)atom).getObject() instanceof String) {
									
									IteratorForTuple _HOCL_tupleAtomIterator8 = (IteratorForTuple)permutation.getAtomIterator(2);
									String _HOCL_literal33 = (String)((IteratorForExternal)_HOCL_tupleAtomIterator8.getAtomIterator(0)).getObject();
									satisfied = _HOCL_literal33.equals("INVOKE");
								}
								return satisfied;
							}
						
						} // end of class AtomIterator__HOCL_literal33
						_HOCL_atomIteratorArrayTuple4[0] = new AtomIterator__HOCL_literal33();
					}
					{
						class AtomIterator_active extends IteratorForExternal {
							public AtomIterator_active(){
								access = Access.REWRITE;
							}
							@Override
							public boolean conditionSatisfied() {
								Atom atom;
								boolean satisfied;
								atom = iterator.getElement();
								satisfied = false;
								if (atom instanceof ExternalObject
								  && ((ExternalObject)atom).getObject() instanceof Integer) {
									
									IteratorForTuple _HOCL_tupleAtomIterator9 = (IteratorForTuple)permutation.getAtomIterator(1);
									Integer value = (Integer)((IteratorForExternal)_HOCL_tupleAtomIterator9.getAtomIterator(1)).getObject();
									IteratorForTuple _HOCL_tupleAtomIterator10 = (IteratorForTuple)permutation.getAtomIterator(2);
									Integer active = (Integer)((IteratorForExternal)_HOCL_tupleAtomIterator10.getAtomIterator(1)).getObject();
									satisfied = (value == 0) && (active == 1);
								}
								return satisfied;
							}
						
						} // end of class AtomIterator_active
						_HOCL_atomIteratorArrayTuple4[1] = new AtomIterator_active();
					}
					_HOCL_atomIteratorArray3[2] = new IteratorForTuple(_HOCL_atomIteratorArrayTuple4, Reset.this);
				}
				MoleculeIterator[] _HOCL_moleculeIteratorArray4 = new MoleculeIterator[0];
				permutation = newPermutation(_HOCL_atomIteratorArray3, _HOCL_moleculeIteratorArray4);
			}
		
			public Reset clone() {
				 return new Reset();
			}
			public void addType(String s){}
		
			// compute result of the rule reset
			protected Molecule computeResult(){
				ExternalObject object;
				ReactionRule rule;
				String[] string;
				Tuple tuple;
				
				IteratorForTuple _HOCL_tupleAtomIterator11 = (IteratorForTuple)permutation.getAtomIterator(0);
				IteratorForSolution _HOCL_iteratorSolution1 = (IteratorForSolution)_HOCL_tupleAtomIterator11.getAtomIterator(1);
				Molecule w = _HOCL_iteratorSolution1.getSubPermutation().getSolution().getContents();
				IteratorForTuple _HOCL_tupleAtomIterator12 = (IteratorForTuple)permutation.getAtomIterator(2);
				Integer active = (Integer)((IteratorForExternal)_HOCL_tupleAtomIterator12.getAtomIterator(1)).getObject();
				Molecule mol25 = new Molecule();
				mol25.add(w);
				Tuple tuple2 = new Tuple(2);
				tuple2.set(0, new ExternalObject("RESET"));
				Solution solution8 = new Solution();
				{
					Molecule mol26 = new Molecule();
					mol26.add(w);
					solution8.addMolecule(mol26);
				}
				tuple2.set(1, solution8);
				tuple = tuple2;
				mol25.add(tuple);
				this.addType("Tuple");
				
				
				Tuple tuple3 = new Tuple(2);
				tuple3.set(0, new ExternalObject("LOCKED"));
				tuple3.set(1, new ExternalObject(1));
				tuple = tuple3;
				mol25.add(tuple);
				this.addType("Tuple");
				
				
				Tuple tuple4 = new Tuple(2);
				tuple4.set(0, new ExternalObject("INVOKE"));
				tuple4.set(1, new ExternalObject(active));
				tuple = tuple4;
				mol25.add(tuple);
				this.addType("Tuple");
				
				
				return mol25;
			}
		
		} // end of class Reset
		
		
		
		
		Molecule mol30 = new Molecule();
		Tuple tuple5 = new Tuple(4);
		tuple5.set(0, new ExternalObject("PASS"));
		tuple5.set(1, new ExternalObject("ChWS_1"));
		tuple5.set(2, new ExternalObject("SampleChService1"));
		Solution solution9 = new Solution();
		{
			Molecule mol31 = new Molecule();
			Tuple tuple6 = new Tuple(2);
			tuple6.set(0, new ExternalObject("INVOKE"));
			tuple6.set(1, new ExternalObject(1));
			tuple = tuple6;
			mol31.add(tuple);
			this.addType("Tuple");
			
			
			object = new ExternalObject("Our");
			mol31.add(object);
			string = object.getObject().getClass().toString().split("\\.");
			this.addType(string[string.length-1]);
			
			
			class _HOCL_RR1 extends ReactionRule implements Serializable {
			
				
				public _HOCL_RR1(){
					super("_HOCL_RR1", Shot.ONE_SHOT);
					setTrope(Trope.EXPANSER);
						AtomIterator[] _HOCL_atomIteratorArray5;
					_HOCL_atomIteratorArray5 = new AtomIterator[1];
					{
						AtomIterator[] _HOCL_atomIteratorArrayTuple5;
						_HOCL_atomIteratorArrayTuple5 = new AtomIterator[3];
						{
							class AtomIterator__HOCL_literal42 extends IteratorForExternal {
								public AtomIterator__HOCL_literal42(){
									access = Access.REWRITE;
								}
								@Override
								public boolean conditionSatisfied() {
									Atom atom;
									boolean satisfied;
									atom = iterator.getElement();
									satisfied = false;
									if (atom instanceof ExternalObject
									  && ((ExternalObject)atom).getObject() instanceof String) {
										
										IteratorForTuple _HOCL_tupleAtomIterator13 = (IteratorForTuple)permutation.getAtomIterator(0);
										String _HOCL_literal42 = (String)((IteratorForExternal)_HOCL_tupleAtomIterator13.getAtomIterator(0)).getObject();
										satisfied = _HOCL_literal42.equals("RESULT");
									}
									return satisfied;
								}
							
							} // end of class AtomIterator__HOCL_literal42
							_HOCL_atomIteratorArrayTuple5[0] = new AtomIterator__HOCL_literal42();
						}
						{
							class AtomIterator__HOCL_literal43 extends IteratorForExternal {
								public AtomIterator__HOCL_literal43(){
									access = Access.REWRITE;
								}
								@Override
								public boolean conditionSatisfied() {
									Atom atom;
									boolean satisfied;
									atom = iterator.getElement();
									satisfied = false;
									if (atom instanceof ExternalObject
									  && ((ExternalObject)atom).getObject() instanceof String) {
										
										IteratorForTuple _HOCL_tupleAtomIterator14 = (IteratorForTuple)permutation.getAtomIterator(0);
										String _HOCL_literal43 = (String)((IteratorForExternal)_HOCL_tupleAtomIterator14.getAtomIterator(1)).getObject();
										satisfied = _HOCL_literal43.equals("ChWS_1");
									}
									return satisfied;
								}
							
							} // end of class AtomIterator__HOCL_literal43
							_HOCL_atomIteratorArrayTuple5[1] = new AtomIterator__HOCL_literal43();
						}
						{
							class AtomIterator_text extends IteratorForExternal {
								public AtomIterator_text(){
									access = Access.REWRITE;
								}
								@Override
								public boolean conditionSatisfied() {
									Atom atom;
									boolean satisfied;
									atom = iterator.getElement();
									satisfied = false;
									if (atom instanceof ExternalObject
									  && ((ExternalObject)atom).getObject() instanceof String) {
										
										IteratorForTuple _HOCL_tupleAtomIterator15 = (IteratorForTuple)permutation.getAtomIterator(0);
										String text = (String)((IteratorForExternal)_HOCL_tupleAtomIterator15.getAtomIterator(2)).getObject();
										satisfied = (text.contains("Our"));
									}
									return satisfied;
								}
							
							} // end of class AtomIterator_text
							_HOCL_atomIteratorArrayTuple5[2] = new AtomIterator_text();
						}
						_HOCL_atomIteratorArray5[0] = new IteratorForTuple(_HOCL_atomIteratorArrayTuple5, _HOCL_RR1.this);
					}
					MoleculeIterator[] _HOCL_moleculeIteratorArray5 = new MoleculeIterator[0];
					permutation = newPermutation(_HOCL_atomIteratorArray5, _HOCL_moleculeIteratorArray5);
				}
			
				public _HOCL_RR1 clone() {
					 return new _HOCL_RR1();
				}
				public void addType(String s){}
			
				// compute result of the rule _HOCL_RR1
				protected Molecule computeResult(){
					ExternalObject object;
					ReactionRule rule;
					String[] string;
					Tuple tuple;
					
					IteratorForTuple _HOCL_tupleAtomIterator16 = (IteratorForTuple)permutation.getAtomIterator(0);
					String text = (String)((IteratorForExternal)_HOCL_tupleAtomIterator16.getAtomIterator(2)).getObject();
					Molecule mol32 = new Molecule();
					Tuple tuple7 = new Tuple(2);
					tuple7.set(0, new ExternalObject("CONDITION_PASS"));
					tuple7.set(1, new ExternalObject(1));
					tuple = tuple7;
					mol32.add(tuple);
					this.addType("Tuple");
					
					
					Tuple tuple8 = new Tuple(3);
					tuple8.set(0, new ExternalObject("RESULT"));
					tuple8.set(1, new ExternalObject("ChWS_1"));
					tuple8.set(2, new ExternalObject(text));
					tuple = tuple8;
					mol32.add(tuple);
					this.addType("Tuple");
					
					
					Tuple tuple9 = new Tuple(3);
					tuple9.set(0, new ExternalObject("DEST"));
					tuple9.set(1, new ExternalObject("ChWS_3"));
					tuple9.set(2, new ExternalObject("SampleChService3"));
					tuple = tuple9;
					mol32.add(tuple);
					this.addType("Tuple");
					
					
					Tuple tuple10 = new Tuple(3);
					tuple10.set(0, new ExternalObject("DEST"));
					tuple10.set(1, new ExternalObject("ChWS_4"));
					tuple10.set(2, new ExternalObject("SampleChService4"));
					tuple = tuple10;
					mol32.add(tuple);
					this.addType("Tuple");
					
					
					return mol32;
				}
			
			} // end of class _HOCL_RR1
			
			rule = new _HOCL_RR1();
			mol31.add(rule);
			this.addType(rule.getName());
			
			
			class _HOCL_RR2 extends ReactionRule implements Serializable {
			
				
				public _HOCL_RR2(){
					super("_HOCL_RR2", Shot.ONE_SHOT);
					setTrope(Trope.EXPANSER);
						AtomIterator[] _HOCL_atomIteratorArray6;
					_HOCL_atomIteratorArray6 = new AtomIterator[1];
					{
						AtomIterator[] _HOCL_atomIteratorArrayTuple6;
						_HOCL_atomIteratorArrayTuple6 = new AtomIterator[3];
						{
							class AtomIterator__HOCL_literal44 extends IteratorForExternal {
								public AtomIterator__HOCL_literal44(){
									access = Access.REWRITE;
								}
								@Override
								public boolean conditionSatisfied() {
									Atom atom;
									boolean satisfied;
									atom = iterator.getElement();
									satisfied = false;
									if (atom instanceof ExternalObject
									  && ((ExternalObject)atom).getObject() instanceof String) {
										
										IteratorForTuple _HOCL_tupleAtomIterator17 = (IteratorForTuple)permutation.getAtomIterator(0);
										String _HOCL_literal44 = (String)((IteratorForExternal)_HOCL_tupleAtomIterator17.getAtomIterator(0)).getObject();
										satisfied = _HOCL_literal44.equals("RESULT");
									}
									return satisfied;
								}
							
							} // end of class AtomIterator__HOCL_literal44
							_HOCL_atomIteratorArrayTuple6[0] = new AtomIterator__HOCL_literal44();
						}
						{
							class AtomIterator__HOCL_literal45 extends IteratorForExternal {
								public AtomIterator__HOCL_literal45(){
									access = Access.REWRITE;
								}
								@Override
								public boolean conditionSatisfied() {
									Atom atom;
									boolean satisfied;
									atom = iterator.getElement();
									satisfied = false;
									if (atom instanceof ExternalObject
									  && ((ExternalObject)atom).getObject() instanceof String) {
										
										IteratorForTuple _HOCL_tupleAtomIterator18 = (IteratorForTuple)permutation.getAtomIterator(0);
										String _HOCL_literal45 = (String)((IteratorForExternal)_HOCL_tupleAtomIterator18.getAtomIterator(1)).getObject();
										satisfied = _HOCL_literal45.equals("ChWS_1");
									}
									return satisfied;
								}
							
							} // end of class AtomIterator__HOCL_literal45
							_HOCL_atomIteratorArrayTuple6[1] = new AtomIterator__HOCL_literal45();
						}
						{
							class AtomIterator_text extends IteratorForExternal {
								public AtomIterator_text(){
									access = Access.REWRITE;
								}
								@Override
								public boolean conditionSatisfied() {
									Atom atom;
									boolean satisfied;
									atom = iterator.getElement();
									satisfied = false;
									if (atom instanceof ExternalObject
									  && ((ExternalObject)atom).getObject() instanceof String) {
										
										IteratorForTuple _HOCL_tupleAtomIterator19 = (IteratorForTuple)permutation.getAtomIterator(0);
										String text = (String)((IteratorForExternal)_HOCL_tupleAtomIterator19.getAtomIterator(2)).getObject();
										satisfied = (text.contains("The"));
									}
									return satisfied;
								}
							
							} // end of class AtomIterator_text
							_HOCL_atomIteratorArrayTuple6[2] = new AtomIterator_text();
						}
						_HOCL_atomIteratorArray6[0] = new IteratorForTuple(_HOCL_atomIteratorArrayTuple6, _HOCL_RR2.this);
					}
					MoleculeIterator[] _HOCL_moleculeIteratorArray6 = new MoleculeIterator[0];
					permutation = newPermutation(_HOCL_atomIteratorArray6, _HOCL_moleculeIteratorArray6);
				}
			
				public _HOCL_RR2 clone() {
					 return new _HOCL_RR2();
				}
				public void addType(String s){}
			
				// compute result of the rule _HOCL_RR2
				protected Molecule computeResult(){
					ExternalObject object;
					ReactionRule rule;
					String[] string;
					Tuple tuple;
					
					IteratorForTuple _HOCL_tupleAtomIterator20 = (IteratorForTuple)permutation.getAtomIterator(0);
					String text = (String)((IteratorForExternal)_HOCL_tupleAtomIterator20.getAtomIterator(2)).getObject();
					Molecule mol33 = new Molecule();
					Tuple tuple11 = new Tuple(2);
					tuple11.set(0, new ExternalObject("CONDITION_PASS"));
					tuple11.set(1, new ExternalObject(1));
					tuple = tuple11;
					mol33.add(tuple);
					this.addType("Tuple");
					
					
					Tuple tuple12 = new Tuple(3);
					tuple12.set(0, new ExternalObject("RESULT"));
					tuple12.set(1, new ExternalObject("ChWS_1"));
					tuple12.set(2, new ExternalObject(text));
					tuple = tuple12;
					mol33.add(tuple);
					this.addType("Tuple");
					
					
					Tuple tuple13 = new Tuple(3);
					tuple13.set(0, new ExternalObject("DEST"));
					tuple13.set(1, new ExternalObject("ChWS_2"));
					tuple13.set(2, new ExternalObject("SampleChService2"));
					tuple = tuple13;
					mol33.add(tuple);
					this.addType("Tuple");
					
					
					return mol33;
				}
			
			} // end of class _HOCL_RR2
			
			rule = new _HOCL_RR2();
			mol31.add(rule);
			this.addType(rule.getName());
			
			
			rule = new StartExecDiscriminator();
			mol31.add(rule);
			this.addType(rule.getName());
			
			
			solution9.addMolecule(mol31);
		}
		tuple5.set(3, solution9);
		tuple = tuple5;
		mol30.add(tuple);
		this.addType("Tuple");
		
		
		rule = new PassInfo();
		mol30.add(rule);
		this.addType(rule.getName());
		
		
		this.addMolecule(mol30);
		this.addType("Solution");
		this.addType("Integer");
		this.addType("String");
		this.addType("Tuple");

	}

	public Molecule addElement(){
		String input = "";
		ExternalObject obj;
		ReactionRule r;
		Molecule mol = new Molecule();
		int choice;

		System.out.println("Create the element that you want to add/remove.\n");
		System.out.println("What kind of element you want to create? (input the number) \n ");
		System.out.println("Supported Elements:");
		System.out.println(this.displayTypes());

		try {
			input += new BufferedReader(new InputStreamReader(System.in)).readLine();
		} catch (IOException e1) {
			e1.printStackTrace();
		}

		try{

			choice = Integer.decode(input);
			input = this.getiAllType(choice-1);
			if(input.length()==0)
				System.out.println("Null pointer!");
			else if (input.equals("Tuple")){
				mol = new Molecule();
				mol.add(generateTupleElement());

				}

			else if (input.equals("Solution")){
				mol = new Molecule();
				mol.add(generateSolutionElement());

				}

			else if (input.equals("String")){
				mol = new Molecule();
				obj = new ExternalObject(generateStringElement());
				mol.add(obj);
				}

			else if (input.equals("Integer")){
				mol = new Molecule();
				obj = new ExternalObject(generateIntegerElement());
				mol.add(obj);
				}

			else if (input.equals("startExecDiscriminator")){
				mol = new Molecule();
				r = new StartExecDiscriminator();
				mol.add(r);
				}

			else if (input.equals("passInfo")){
				mol = new Molecule();
				r = new PassInfo();
				mol.add(r);
				}

				else{
					Package pack = this.getClass().getPackage();
					String packageName = pack.getName();
					String ts = input.substring(0, 1).toUpperCase()+input.substring(1);
					ReactionRule m = (ReactionRule) Class.forName(packageName+"."+ts).newInstance();
 					mol.add(m);

					System.out.println("The new rule has been added!");
			}

		return mol;
		}

		catch  (Exception e) {

			System.out.println("Input Error! Please input *NUMBER* while not string!");			return mol;		}

	}
	public Molecule addElementSubSolution(String line) throws IOException{
		Molecule mol = new Molecule();
		String[] s = line.split("\\ ");
		if(s.length!=2){
			String errorLog=	"Input command with wrong format.\n"
			+	"Use 'put' command in the following ways:\n"
			+	"1: 'put'; (just put an element in the container;)\n"
			+	"2: 'put path' ex.: put ./SubSolition1/SubSolution1-1 (put an element in the indicated subsolution.)\n";
			System.out.println(errorLog);
		}

		else{
			//System.out.println("The length of input command is: " + s.length +"\n");
			//System.out.println("S0 is: " + s[0] +"\n");
			//System.out.println("S1 is: " + s[1] +"\n");
			String[] path = s[1].split("\\/");
			int size = path.length;
			Tuple[] tuple = new Tuple[size-1];

			tuple[size-2] = new Tuple(3);
			tuple[size-2].set(0, new ExternalObject("INSERT"));
			tuple[size-2].set(1, new ExternalObject(path[size-1]));
			tuple[size-2].set(2, (this.generateSolutionElement()));

			for (int i = size-3;i>=0;i--){
				tuple[i] = new Tuple(3);
				tuple[i].set(0, new ExternalObject("INSERT"));
				tuple[i].set(1, new ExternalObject(path[i+1]));
				Solution so = new Solution();
				Molecule mo = new Molecule();
				mo.add(tuple[i+1]);
				so.addMolecule(mo);
				tuple[i].set(2, so);
			}

			mol.add(tuple[0]);
		}
		return mol;
	}

	public Molecule addRemoveTuple() throws IOException{
		System.out.println("We are going to construct a solution for all the elements that you want to remove.");
		Tuple t = new Tuple(2);
		t.set(0, new ExternalObject("REMOVE"));
		t.set(1, this.generateSolutionElement());
		Molecule mo = new Molecule();
		mo.add(t);
		return mo;
	}

	public Molecule addInheritRemoveTuple(String line) throws IOException{
				Molecule m = new Molecule();
		String[] s = line.split("\\ ");
		if(s.length!=2){
			String errorLog=	"Input command with wrong format.\n"
			+	"Use 'get' command in the following ways:\n"
			+	"1: 'get'; (just get an element in the container;)\n"
			+	"2: 'get path' ex.: get ./SubSolition1/SubSolution1-1 (get the elements in the indicated subsolution.)\n";
			System.out.println(errorLog);
		}

		else{
			if(!s[1].contains("/"))
				System.out.println("You have given a wrong solution path.\n");
			else{
				System.out.println("We are going to construct a solution for all the elements that you want to remove.");
				String[] path = s[1].split("\\/");
				int size = path.length;
				Tuple[] tuple = new Tuple[size-1];

				tuple[size-2] = new Tuple(3);
				tuple[size-2].set(0, new ExternalObject("REMOVE"));
				tuple[size-2].set(1, new ExternalObject(path[size-1]));
				Solution so = new Solution();
				Molecule mo = new Molecule();
				Tuple tt = new Tuple(2);
				tt.set(0, new ExternalObject("REMOVE"));
				tt.set(1,this.generateSolutionElement());
				mo.add(tt);
				so.addMolecule(mo);
				tuple[size-2].set(2, so);
				for (int i = size-3;i>=0;i--){
					tuple[i] = new Tuple(3);
					tuple[i].set(0, new ExternalObject("REMOVE"));
					tuple[i].set(1, new ExternalObject(path[i+1]));
					so = new Solution();
					mo = new Molecule();
					mo.add(tuple[i+1]);
					so.addMolecule(mo);
					tuple[i].set(2, so);
				}

				m.add(tuple[0]);
			}
		}
		return m;
	}



	public String generateStringElement() throws IOException{;
		System.out.println("Enter your String:\n");
		String input = new BufferedReader(new InputStreamReader(System.in)).readLine();
		return new String(input);

	}
	public Integer generateIntegerElement() throws IOException{;
		System.out.println("Enter your Integer:\n");
		String input = new BufferedReader(new InputStreamReader(System.in)).readLine();
		return new Integer(input);

	}


	public Tuple generateTupleElement() throws IOException{
		int num;
		String input;

		System.out.println("How many elements in the tuple?\n");
		input = new BufferedReader(new InputStreamReader(System.in)).readLine();
		num = Integer.decode(input);

		Tuple t = new Tuple (num);
		for (int i=0;i<num;i++){
			System.out.print("Enter the type for the ");
			int j = i % 10;
			if (j == 0)
				System.out.println((i+1) + "st element. \n");
			else if (j == 1)
				System.out.println((i+1) + "nd element. \n");
			else if (j == 2)
				System.out.println((i+1) + "rd element. \n");
			else 
				 System.out.println((i+1) + "th element. \n");
			System.out.println("Types:");
			System.out.println(this.displayTypes());
			input = new BufferedReader(new InputStreamReader(System.in)).readLine();

			while(input.length()==0){
				System.out.println("Enter the type of the element.");
				input = new BufferedReader(new InputStreamReader(System.in)).readLine();
			}
			 int choice = Integer.decode(input);
			 input = this.getiAllType(choice-1);
			if(input.equals("Tuple")){
				t.set(i, generateTupleElement());
			}

			else if(input.equals("Solution")){
					t.set(i, generateSolutionElement());
				}

			else if(input.equals("String")){
				t.set(i, new ExternalObject (generateStringElement()));
			}

			else if(input.equals("Integer")){
				t.set(i, new ExternalObject (generateIntegerElement()));
			}

			else if(input.equals("startExecDiscriminator")){
				t.set(i, new StartExecDiscriminator());
			}

			else if(input.equals("passInfo")){
				t.set(i, new PassInfo());
			}

		}
		return t;
	}



	public Solution generateSolutionElement() throws IOException{
		int sign = 0;
		String input;
		Solution sol = new Solution ();
		Molecule mol = new Molecule();
		while(sign == 0){
			System.out.println("Do you want to add an element in this solution? (y/n)");
			String stop = new BufferedReader(new InputStreamReader(System.in)).readLine();

			if (stop.equals("yes")||stop.equals("y")||stop.equals("YES")||stop.equals("Y")){
				System.out.println("Enter the type of the element.\n");
				System.out.println("Types:");
				System.out.println(this.displayTypes());
				input = new BufferedReader(new InputStreamReader(System.in)).readLine();

				while(input.length()==0){
					System.out.println("Enter the type of the element.");
					input = new BufferedReader(new InputStreamReader(System.in)).readLine();
				}
				int choice = Integer.decode(input);
				input = this.getiAllType(choice-1);
				if(input.equals("Tuple")){
					mol = new Molecule();
					mol.add(generateTupleElement());
					sol.addMolecule(mol);
				}

				else if(input.equals("Solution")){
					mol.add(generateSolutionElement());
					sol.addMolecule(mol);

				}

				else if(input.equals("String")){
					mol = new Molecule();
					mol.add(new ExternalObject (generateStringElement())) ;
					sol.addMolecule(mol);
				}

				else if(input.equals("Integer")){
					mol = new Molecule();
					mol.add(new ExternalObject (generateIntegerElement())) ;
					sol.addMolecule(mol);
				}

				else if(input.equals("startExecDiscriminator")){
					mol = new Molecule();
					mol.add(new StartExecDiscriminator());
					sol.addMolecule(mol);
				}

				else if(input.equals("passInfo")){
					mol = new Molecule();
					mol.add(new PassInfo());
					sol.addMolecule(mol);
				}

				else{
					try{
						String ts = input.substring(0, 1).toUpperCase()+input.substring(1);
						ReactionRule m = (ReactionRule) Class.forName(input).newInstance();
						mol.add(m);
						sol.addMolecule(mol);
					}catch(Exception e){
						System.out.println("Error: (Test1_gen.generateSolutionElement()): "+e+".");
					}
				}
			}

			else{sign=1;}

		}

		return sol;
	}
	public void addType(String s){
		int sign=0;

		if(this.getAllTypeSize()==0){
			this.addToAllTypes(s);
		}

		else{
			for (int i=0;i<this.getAllTypeSize();i++){
				if (this.getiAllType(i).equals(s)){
					sign=1;
					break;
				}
			}
			if (sign==0){
				this.addToAllTypes(s);
			}
		}
	}

	public String displayTypes (){

		String types = "";

		if(this.getAllTypeSize()==0){
			types = "No element in the multi-set.\n";
		}
		else{
			for(int i=0;i<this.getAllTypeSize();i++){
			if (!this.getiAllType(i).equals("IOSender"))
				types += i+1 +": "+this.getiAllType(i)+";\n";
			}
		}
		return types;
	}
} // class ClientChService_gen

